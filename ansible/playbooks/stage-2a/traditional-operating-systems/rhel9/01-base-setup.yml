---
# -----------------------------------------------------------------------------
# Traditional OS - RHEL9 - Base Setup
#
# Features:
# - Require --limit (fail fast)
# - Bootstrap path (optional): if desired SSH port is not reachable but bootstrap is
# - SELinux: allow non-standard SSH port via community.general.seport
# - Bootstrap firewall: open desired SSH port (temporary/simple; final policy elsewhere)
# - Reconnect after SSH port change (wait_for + set ansible_port + wait_for_connection)
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# PreCheck: enforce --limit
# -----------------------------------------------------------------------------
- name: PreCheck (require --limit)
  hosts: all
  gather_facts: false
  any_errors_fatal: true

  tasks:
    - name: Verify that a limit is set
      ansible.builtin.fail:
        msg: "This playbook cannot be run without --limit. Please use --limit <host-or-group>."
      run_once: true
      when: ansible_limit is not defined
      tags: [always]

    - name: Show limit
      ansible.builtin.debug:
        msg: "Limit is {{ ansible_limit }}, continuing."
      run_once: true
      when: ansible_limit is defined
      tags: [always]


# -----------------------------------------------------------------------------
# Bootstrap: only when desired SSH port is unreachable but bootstrap works
# -----------------------------------------------------------------------------
- name: Bootstrap (when desired SSH is unreachable but bootstrap works)
  hosts: all
  gather_facts: false
  become: false
  any_errors_fatal: true

  vars:
    # Desired SSH port (final state)
    _sshd_port_desired: "{{ sshd_port | default(22) | int }}"

    # Normal probe port: ALWAYS the desired port (no ansible_port recursion).
    _probe_port_normal: "{{ _sshd_port_desired }}"

    # Bootstrap path port (factory/installer login)
    _probe_port_bootstrap: "{{ linux_bootstrap_ssh_port | default(22) | int }}"

    # Optional: which zone to open for the bootstrap port rule (temporary)
    _bootstrap_firewalld_zone: "{{ bootstrap_firewalld_zone | default('public') }}"

    # Bootstrap is considered "configured" if any of these are set.
    _bootstrap_configured: >-
      {{
        (linux_bootstrap_user | default('') | length > 0)
        or (linux_bootstrap_password | default('') | length > 0)
        or (linux_bootstrap_ssh_port is defined)
        or (lookup('env', 'ANSIBLE_BOOTSTRAP_USER') | default('') | length > 0)
        or (lookup('env', 'ANSIBLE_BOOTSTRAP_PASSWORD') | default('') | length > 0)
      }}

    bootstrap_user_effective: >-
      {{
        linux_bootstrap_user
          | default(lookup('env', 'ANSIBLE_BOOTSTRAP_USER'), true)
          | default(lookup('env', 'ANSIBLE_USER'), true)
          | default('root', true)
      }}

    bootstrap_password_effective: >-
      {{
        linux_bootstrap_password
          | default(lookup('env', 'ANSIBLE_BOOTSTRAP_PASSWORD'), true)
          | default(omit)
      }}

  pre_tasks:
    - name: Check reachability on desired SSH port (normal path)
      ansible.builtin.ping:
      ignore_unreachable: true
      ignore_errors: true
      register: ping_normal
      vars:
        ansible_port: "{{ _probe_port_normal }}"
      tags: [bootstrap]

    - name: Check reachability on bootstrap SSH port
      ansible.builtin.ping:
      ignore_unreachable: true
      ignore_errors: true
      register: ping_bootstrap
      vars:
        ansible_port: "{{ _probe_port_bootstrap }}"
        ansible_user: "{{ bootstrap_user_effective }}"
        ansible_password: "{{ bootstrap_password_effective }}"
      when: _bootstrap_configured | bool
      tags: [bootstrap]

    - name: Derive reachability flags
      ansible.builtin.set_fact:
        _normal_ok: "{{ not (ping_normal is failed or (ping_normal.unreachable | default(false))) }}"
        _bootstrap_ok: >-
          {{
            _bootstrap_configured | bool
            and not (ping_bootstrap is failed or (ping_bootstrap.unreachable | default(false)))
          }}
      changed_when: false
      tags: [bootstrap]

    - name: Decide whether bootstrap is needed
      ansible.builtin.set_fact:
        _bootstrap_needed: "{{ (not _normal_ok) and _bootstrap_ok }}"
      changed_when: false
      tags: [bootstrap]

    - name: Compute reconnect flag (bootstrap only; when desired port differs from bootstrap port)
      ansible.builtin.set_fact:
        _sshd_reconnect_after_change: >-
          {{
            _bootstrap_needed | bool
            and (_sshd_port_desired | int) != (_probe_port_bootstrap | int)
          }}
      changed_when: false
      tags: [bootstrap]

    - name: Show connection mode
      ansible.builtin.debug:
        msg: >-
          Connection mode: {{
            _bootstrap_needed
              | ternary('BOOTSTRAP (using bootstrap creds/port)',
                        'NORMAL (desired SSH port already reachable)')
          }}
      tags: [bootstrap]

    - name: Fail if host is unreachable and bootstrap is not configured
      ansible.builtin.fail:
        msg: >-
          Host {{ inventory_hostname }} is unreachable on desired SSH port ({{ _probe_port_normal }}),
          and bootstrap is not configured. Set linux_bootstrap_* vars (or ANSIBLE_BOOTSTRAP_* env vars).
      when:
        - not _normal_ok
        - not _bootstrap_configured | bool
      tags: [bootstrap]

    - name: Fail if host is unreachable on both paths (bootstrap configured)
      ansible.builtin.fail:
        msg: >-
          Host {{ inventory_hostname }} is unreachable on both:
          - desired port: {{ _probe_port_normal }}
          - bootstrap port: {{ _probe_port_bootstrap }}
      when:
        - not _normal_ok
        - _bootstrap_configured | bool
        - not _bootstrap_ok
      tags: [bootstrap]

  tasks:
    - name: Bootstrap - ensure users exist
      ansible.builtin.include_role:
        name: lit.rhel.users
        apply:
          become: true
      when: _bootstrap_needed | bool
      vars:
        ansible_user: "{{ bootstrap_user_effective }}"
        ansible_password: "{{ bootstrap_password_effective | default(omit) }}"
        ansible_port: "{{ _probe_port_bootstrap }}"
      tags: [bootstrap]

    - name: Bootstrap - gather minimal facts (SELinux)
      ansible.builtin.setup:
        gather_subset:
          - "!all"
          - "!min"
          - selinux
      when:
        - _bootstrap_needed | bool
        - (_sshd_port_desired | int) != 22
      tags: [bootstrap]

    - name: Bootstrap - SELinux allow desired SSH port (ssh_port_t)
      community.general.seport:
        ports: "{{ _sshd_port_desired | int }}"
        proto: tcp
        setype: ssh_port_t
        state: present
      when:
        - _bootstrap_needed | bool
        - (_sshd_port_desired | int) != 22
        - ansible_facts.selinux is defined
        - ansible_facts.selinux.status | default('disabled') == 'enabled'
      tags: [bootstrap]

    # Temporary bootstrap firewall opening for the desired SSH port.
    # Final firewall policy is applied later via group-specific playbooks/vars.
    - name: Bootstrap - ensure firewalld is installed
      ansible.builtin.package:
        name: firewalld
        state: present
      when:
        - _bootstrap_needed | bool
        - _sshd_reconnect_after_change | bool
      become: true
      tags: [bootstrap]

    - name: Bootstrap - enable and start firewalld
      ansible.builtin.service:
        name: firewalld
        state: started
        enabled: true
      when:
        - _bootstrap_needed | bool
        - _sshd_reconnect_after_change | bool
      become: true
      tags: [bootstrap]

    - name: Bootstrap - open desired SSH port in firewalld
      ansible.posix.firewalld:
        port: "{{ _sshd_port_desired | int }}/tcp"
        zone: "{{ _bootstrap_firewalld_zone }}"
        permanent: true
        immediate: true
        state: enabled
      when:
        - _bootstrap_needed | bool
        - _sshd_reconnect_after_change | bool
      become: true
      tags: [bootstrap]

    - name: Bootstrap - configure sshd (set Port via sshd_config)
      ansible.builtin.include_role:
        name: fedora.linux_system_roles.sshd
        apply:
          become: true
      when: _bootstrap_needed | bool
      vars:
        ansible_user: "{{ bootstrap_user_effective }}"
        ansible_password: "{{ bootstrap_password_effective | default(omit) }}"
        ansible_port: "{{ _probe_port_bootstrap }}"
      tags: [bootstrap]

    # IMPORTANT: flush sshd handlers while we are still connected via bootstrap port.
    # Otherwise the handler may run after the port change and try to connect on the old port.
    - name: Bootstrap - flush handlers before reconnect
      ansible.builtin.meta: flush_handlers
      tags: [bootstrap]

    - name: Reconnect after SSH port change
      block:
        - name: Wait for new SSH port (controller-side)
          ansible.builtin.wait_for:
            host: "{{ ansible_host | default(inventory_hostname) }}"
            port: "{{ _sshd_port_desired | int }}"
            timeout: 180
          delegate_to: localhost

        - name: Switch Ansible to new port
          ansible.builtin.set_fact:
            ansible_port: "{{ _sshd_port_desired | int }}"
          changed_when: false

        - name: Wait for SSH connection on new port
          ansible.builtin.wait_for_connection:
            timeout: 180
      when: _sshd_reconnect_after_change | bool
      tags: [bootstrap]


# -----------------------------------------------------------------------------
# Base setup (inventory defaults)
# -----------------------------------------------------------------------------
- name: Base setup
  hosts: all
  gather_facts: true
  become: true
  any_errors_fatal: true

  vars:
    _sshd_port_desired: "{{ sshd_port | default(22) | int }}"

  tasks:
    - name: Users
      ansible.builtin.include_role:
        name: lit.rhel.users
      tags: [users]

    - name: Baseline
      ansible.builtin.include_role:
        name: lit.rhel.baseline
      tags: [baseline, base_config]

    - name: VLAN trunk autogen
      # If net_trunk_parent + net_vlan_configs are defined, generate network_connections automatically.
      ansible.builtin.include_role:
        name: lit.foundational.net_vlan_autogen
      tags: [network]

    - name: Network
      ansible.builtin.include_role:
        name: fedora.linux_system_roles.network
        apply:
          tags: [network]
      when: (network_connections | default([], true) | length) > 0
      tags: [network]

    - name: Sysctl
      ansible.posix.sysctl:
        name: "{{ item.name }}"
        value: "{{ item.value }}"
        state: "{{ item.state | default('present') }}"
        reload: "{{ item.reload | default(false) }}"
      loop: "{{ sysctl_settings | default([], true) }}"
      when: (sysctl_settings | default([], true) | length) > 0
      tags: [sysctl]

    - name: Timesync
      ansible.builtin.include_role:
        name: fedora.linux_system_roles.timesync
      when: (timesync_ntp_servers | default([])) | length > 0
      tags: [timesync, chronyd]

    - name: Firewalld (non-firewall hosts only)
      ansible.builtin.include_role:
        name: fedora.linux_system_roles.firewalld
      when: "'firewalls' not in group_names"
      tags: [firewalld]

    - name: SSHD - SELinux allow desired SSH port
      community.general.seport:
        ports: "{{ _sshd_port_desired | int }}"
        proto: tcp
        setype: ssh_port_t
        state: present
      when:
        - (_sshd_port_desired | int) != 22
        - ansible_facts.selinux is defined
        - ansible_facts.selinux.status | default('disabled') == 'enabled'
      tags: [sshd]

    - name: SSHD
      ansible.builtin.include_role:
        name: fedora.linux_system_roles.sshd
        apply:
          tags: [sshd]
      tags: [sshd]

    - name: Hostname
      ansible.builtin.include_role:
        name: lit.rhel.hostname
        apply:
          tags: [hostname]
      tags: [hostname]

    - name: Automatic updates
      ansible.builtin.include_role:
        name: lit.rhel.automatic_updates
      tags: [automatic_updates]
